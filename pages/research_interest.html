<div class="publications_div">

    <p class="subtitle"> BAD CODE SMELLS DETECTION AND MANAGEMENT</p>   
    <p class="text">  Bad code smells have been defined by Martin Fowler as symptoms of poor design and implementation 
        choices. Bad smells are usually introduced in software systems because developers poorly conceived the design of 
        the code component or because they did not care about properly designing the solution due to strict deadlines. 
        Complex Class, i.e., a class that contain complex methods and it is very large in terms of LOC; or God Class, 
        i.e., a class that does too much/knows too much about other classes, are only some examples of a plethora of bad 
        smells identified and characterized in well-known catalogues. Recent empirical studies showed that code smells 
        hinder comprehensibility, and possibly increase change- and fault- proneness. For these reasons, the main 
        research topics in this area are the definition of new approaches able to (i) detect bad code smells in the source code; 
        (ii) prioritize the results of detection tools; (iii) study the reason behind their introduction and removal; and 
        (iv) recommend their removal through appropriate refactorings operation.
    </p> <br>

    <p class="subtitle"> BUG PREDICTION</p>   
    <p class="text">  Allocating resources for the testing and the verification of all the parts of a large software system is a cost-prohibitive task. To alleviate this issue, prediction models able to identify portions of source code more prone to contain bugs have been the object of several studies. The main research topic is the definition of accurate prediction models that, on the one hand use a suitable set of predictors able to characterize the bug-proneness of code components, and on the other hand is able to use appropriate machine learning techniques to distinguish those components affected by bug.
    </p> <br>

    <p class="subtitle"> MOBILE SOFTWARE ENGINEERING</p>   
    <p class="text">  According to recent statistics, over two billion users rely on smartphones and tablets to perform their daily activities. Not only do users play games or send messages, they use mobile apps for every type of need, including social and emergency connectivity. Mobile software engineering is the field responsible for the definition of techniques able to improve the life of both mobile developers and end users. The main research topic includes the application of mining software repositories techniques in the context of user reviews, with the goal of extracting actionable knowledge to incorporate in novel techniques and tools helping developers in performing their activities.
    </p> <br>

    <p class="subtitle"> TRACEABILITY MANAGEMENT </p>   
    <p class="text">  Traceability has been defined as "the ability to describe and follow the life of an artifact,
        in both a forwards and backwards direction". Thus, traceability links help software engineers to understand 
        the relationships and dependencies among various software artifacts (requirements, code, tests, models, etc.)
        developed during the software lifecycle. The two main research topics related to the traceability management 
        are event-based systems for traceability management and information retrieval based methods and tools
        supporting the software engineer in the traceability link recovery.
    </p> <br>

    <p class="subtitle"> MINING SOFTWARE REPOSITORIES</p>   
    <p class="text">  Software repositories such as source control systems, archived communications between project 
        personnel, and defect tracking systems are used to help manage the progress of software projects. Software 
        practitioners and researchers are recognizing the benefits of mining this information to support the maintenance 
        of software systems, improve software design/reuse, and empirically validate novel ideas and techniques. 
        Research is now proceeding to uncover the ways in which mining these repositories can help to understand software 
        development and software evolution, to support predictions about software development, and to exploit this 
        knowledge in planning future development. 
    </p> <br>

    <p class="subtitle"> EMPIRICAL SOFTWARE ENGINEERING</p>   
    <p class="text">  Empirical software engineering is a sub-domain of software engineering focusing on experiments 
        on software systems (software products, processes, and resources). It is interested in devising experiments on 
        software, in collecting data from these experiments, and in devising laws and theories from this data. 
        Proponents of experimental software engineering advocate that the nature of software is such that we can advance 
        the knowledge on software through experiments only. The scientific method suggests a cycle of observations, 
        laws, and theories to advance science. Empirical software engineering applies this method to software.
    </p> <br>

</div>

<script>
    (function (i, s, o, g, r, a, m) {
        i['GoogleAnalyticsObject'] = r;
        i[r] = i[r] || function () {
            (i[r].q = i[r].q || []).push(arguments)
        }, i[r].l = 1 * new Date();
        a = s.createElement(o),
                m = s.getElementsByTagName(o)[0];
        a.async = 1;
        a.src = g;
        m.parentNode.insertBefore(a, m)
    })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

    ga('create', 'UA-55444259-1', 'auto');
    ga('send', 'pageview');

</script>
